//variables for tft screen
#include <TFT_eSPI.h>
TFT_eSPI tft = TFT_eSPI();
#define BLACK 0x0000
#define BLUE 0x001F
#define RED 0xF800
#define GREEN 0x07E0
#define CYAN 0x07FF
#define MAGENTA 0xF81F
#define YELLOW 0xFFE0
#define WHITE 0xFFFF
float width = tft.width();
float height = tft.height();

//variables for startscreen
bool setup123 = true;

//variables for goodEndScreen
bool goodEndSetup = true;

//variables for badEndScreen
bool badEndSetup = true;

//variables for countdown timer
#include LiquidCrystal.h

bool countdown = true;
int countdownTime = 15;
int buzzerpin = 28;

//variables for decodePuzzle

//variables for lightPuzzle
#include <Keypad.h>

const byte ROWS = 4;
const byte COLS = 4;
char keys[ROWS][COLS] = {
  {'1', '2', '3', 'A'},
  {'4', '5', '6', 'B'},
  {'7', '8', '9', 'C'},
  {'*', '0', '#', 'D'}
};
byte rowPins[ROWS] = {9, 8, 7, 6};
byte colPins[COLS] = {5, 4, 3, 2};
Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);

const int ledPin1 = 10;
const int ledPin2 = 11;
const int ledPin3 = 12;
const int ledPin4 = 13;
const int ledPin5 = A1;
const int ledPin6 = A2;
const int ledPin7 = A3;
const int ledPin8 = A4;
const int ledPin9 = A5;
const int ledPin10 = A6;

const int ledPins[] = {ledPin1, ledPin2, ledPin3, ledPin4, ledPin5, ledPin6, ledPin7, ledPin8};
const int numLeds = sizeof(ledPins) / sizeof(ledPins[0]);
randomSeed(analogRead(0));

//variables for arrowPuzzle
bool selectColour = true;
bool selectSerialNumber = true;
bool wireGen = true;
bool randomNumGenerate = true;
bool UPdownPuzzleSolve = false;
int randomNumber;
int arrowCode[6]; //UP == 1, DOWN == 2, LEFT == 3, RIGHT == 4
int arrowCodeEnter[6];
int arrowCodeIndex = 0;
int numWires;
int buttonPin = 38;     // the number of the button pin
int buttonPin2 = 39;
int buttonPin3 = 40;
int buttonPin4 = 41;
int buttonState = 0;   // current state of the button
int buttonState2 = 0;
int buttonState3 = 0;
int buttonState4 = 0;
int lastButtonState = 0;  // previous state of the button
int lastButtonState2 = 0;
int lastButtonState3 = 0;
int lastButtonState4 = 0;
int wirenum;
int randomNum1;
int randomNum2;
int randomNum3;
int realNum1;
int realNum2;
int realNum3;


//variables for joystick
#define JOYSTICK_X_PIN A7
#define JOYSTICK_Y_PIN A8
#define JOYSTICK_BUTTON_PIN 34
float cursorX = 240.0;
float cursorY = 160.0;

//variables for switching screens and such
bool startScreen = true;
bool gameScreen = false;
bool badEndScreen = false;
bool goodEndScreen = false;

//////////////////////////////////////
//setup
void setup(){
  // lcd setup
  lcd.begin(16, 2);
  pinMode(buzzerpin, OUTPUT);
  
  //pins for buttons
  pinMode(buttonPin, INPUT);
  pinMode(buttonPin2, INPUT);
  pinMode(buttonPin3, INPUT);
  pinMode(buttonPin4, INPUT);
  
  //pins for tft screen
  
  //pins for lcd display
  
  //pins for LEDS
  Serial.begin(9600);

  // Set up LED pins as outputs
  for (int i = 0; i < numLeds; i++) {
    pinMode(ledPins[i], OUTPUT);
    
  randomSeed(analogRead(A15));
  randomNum1 = (random(6));
  randomNum2 = (random(7));
  randomNum3 = (random(7));
  wirenum = random(1,4);

  realNum1 = (randomNum1 + wirenum);
  realNum2 = (randomNum2 + wirenum);
  realNum3 = (randomNum3 + wirenum);
  }
  
  //pins for buzzers
  
  //pins for joystick
  pinMode(JOYSTICK_BUTTON_PIN, INPUT);
  digitalWrite(JOYSTICK_BUTTON_PIN, HIGH);
  
}//end setup

//////////////////////////////////////
//loop
void loop(){
  if (startScreen){
    startScreen();
  } else if (gameScreen){
    gameScreen();
    COUNTDOWN();
  } else if (goodEndScreen){
    goodEndScreen();
  } else if (badEndScreen){
    badEndScreen();
  }
}//end loop

//////////////////////////////////////
//startscreen
void startScreen(){
  if (setup123){
    tft.fillScreen(BLACK);

    //Easy button
    tft.drawRoundRect(150, 100, 200, 50, 5, WHITE);
    tft.setCursor(220, 115);
    tft.setTextColor(RED);
    tft.setTextSize(3);
    tft.println("Easy");

    //Medium button
    tft.drawRoundRect(150, 170, 200, 50, 5, WHITE);
    tft.setCursor(205, 185);
    tft.setTextColor(RED);
    tft.setTextSize(3);
    tft.println("Medium");

    //Hard button
    tft.drawRoundRect(150, 240, 200, 50, 5, WHITE);
    tft.setCursor(215, 255);
    tft.setTextColor(RED);
    tft.setTextSize(3);
    tft.println("Hard");

    tft.setCursor(30, 20);
    tft.setTextColor(BLACK, RED);
    tft.setTextSize(10);
    tft.println("NOT A BOMB");
    
    setup123 = false;
  }

  // Read input and map change the range from 0 - 1023 to -0.05 to 0.05. map() only creates integers. 
  float JoyStickX = map(analogRead(JOYSTICK_X_PIN), 0, 1023, -1000, 1000)/20000.0;
  float JoyStickY = map(analogRead(JOYSTICK_Y_PIN), 0, 1023, -1000, 1000)/20000.0;

  // Update cursor position
  cursorY = cursorY + JoyStickY;
  cursorX = cursorX + JoyStickX;

  // Limit the cursor to the bounds of the screen
  cursorX = constrain(cursorX, 0,480);
  cursorY = constrain(cursorY, 0,320);

  // Read the pin for the button in the joystick, and if pressed add one to resetCount. Otherwise, reset it to 0.
  if (digitalRead(JOYSTICK_BUTTON_PIN) == 0 && cursorX >= 150 && cursorX <= 350 && cursorY >= 100 && cursorY <= 150) {
    startScreen = false;
    gameScreen = true;
  } else if (digitalRead(JOYSTICK_BUTTON_PIN) == 0 && cursorX >= 150 && cursorX <= 350 && cursorY >= 170 && cursorY <= 220) {
    startScreen = false;
    gameScreen = true;
  } else if (digitalRead(JOYSTICK_BUTTON_PIN) == 0 && cursorX >= 150 && cursorX <= 350 && cursorY >= 240 && cursorY <= 290) {
    startScreen = false;
    gameScreen = true;
  }


  // Finally, draw a pixel where the cursor currently is 
  tft.drawPixel(int(cursorX), int(cursorY), WHITE);
}//endstartscreen

//////////////////////////////////////
//gameScreen
void gameScreen(){
  tft.fillScreen(BLACK);

  tft.drawRect(50,25,100,25,TFT_WHITE);
  tft.fillRect(50,25,100,25,TFT_WHITE);

  tft.drawRect(50,170,100,25,TFT_WHITE);
  tft.fillRect(50,170,100,25,TFT_WHITE);

  tft.drawRect(50,210,200,100,TFT_DARKGREY);
  tft.fillRect(50,210,10,100, TFT_DARKGREY);
  tft.fillRect(50,210,200,10,TFT_DARKGREY);
  tft.fillRect(240,210,10,100, TFT_DARKGREY);
  tft.fillRect(50,300,200,10,TFT_DARKGREY);
  
  int wireXPos = 67;
  for(int i = 0; i < wirenum; i++){
    tft.fillRect(wireXPos, 45, 15, 130, RED);
    wireXPos += 25;
    }

}//end gamescreen

//////////////////////////////////////
//badEndScreen
void badEndScreen(){
  if (badEndSetup){
    tft.fillScreen(BLACK);

    tft.setCursor(30, 100);
    tft.setTextColor(BLACK, RED);
    tft.setTextSize(5);
    tft.println("YOU LOSE!(OOF)");

    tft.drawRoundRect(150, 170, 200, 50, 5, WHITE);
    tft.setCursor(220, 180);
    tft.setTextColor(RED);
    tft.setTextSize(3);
    tft.println("Home");

    badEndSetup = false;
  }

  // Read input and map change the range from 0 - 1023 to -0.05 to 0.05. map() only creates integers. 
  float JoyStickX = map(analogRead(JOYSTICK_X_PIN), 0, 1023, -1000, 1000)/20000.0;
  float JoyStickY = map(analogRead(JOYSTICK_Y_PIN), 0, 1023, -1000, 1000)/20000.0;

  // Update cursor position
  cursorY = cursorY + JoyStickY;
  cursorX = cursorX + JoyStickX;

  // Limit the cursor to the bounds of the screen
  cursorX = constrain(cursorX, 0,480);
  cursorY = constrain(cursorY, 0,320);

  // Read the pin for the button in the joystick, and if pressed add one to resetCount. Otherwise, reset it to 0.
  if (digitalRead(JOYSTICK_BUTTON_PIN) == 0 && cursorX >= 150 && cursorX <= 350 && cursorY >= 170 && cursorY <= 220) {
    badEndScreen = false;
    startScreen = true;
    setup123 = true;
  }
  
  // Finally, draw a pixel where the cursor currently is 
  tft.drawPixel(int(cursorX), int(cursorY), WHITE);
}//end badEndScreen

//////////////////////////////////////
//good end screen
void goodEndScreen(){
  if (goodEndSetup){
    tft.fillScreen(BLACK);

    tft.setCursor(0, 100);
    tft.setTextColor(BLACK, RED);
    tft.setTextSize(5);
    tft.println("YOU WIN!(HOORAY)");

    tft.drawRoundRect(150, 170, 200, 50, 5, WHITE);
    tft.setCursor(220, 180);
    tft.setTextColor(RED);
    tft.setTextSize(3);
    tft.println("Home");

    goodEndSetup = false;
  }

  // Read input and map change the range from 0 - 1023 to -0.05 to 0.05. map() only creates integers. 
  float JoyStickX = map(analogRead(JOYSTICK_X_PIN), 0, 1023, -1000, 1000)/20000.0;
  float JoyStickY = map(analogRead(JOYSTICK_Y_PIN), 0, 1023, -1000, 1000)/20000.0;

  // Update cursor position
  cursorY = cursorY + JoyStickY;
  cursorX = cursorX + JoyStickX;

  // Limit the cursor to the bounds of the screen
  cursorX = constrain(cursorX, 0,480);
  cursorY = constrain(cursorY, 0,320);

  // Read the pin for the button in the joystick, and if pressed add one to resetCount. Otherwise, reset it to 0.
  if (digitalRead(JOYSTICK_BUTTON_PIN) == 0 && cursorX >= 150 && cursorX <= 350 && cursorY >= 170 && cursorY <= 220) {
    goodEndScreen = false;
    startScreen = true;
    setup123 = true;
  }

  // Finally, draw a pixel where the cursor currently is 
  tft.drawPixel(int(cursorX), int(cursorY), WHITE);
}//end goodEndScreen

//////////////////////////////////////
//COUNTDOWN
void COUNTDOWN(){
  void loop() {
  
  // print the initial countdown time on the LCD screen
  lcd.print("Countdown: ");
  lcd.print(countdownTime - 1);
  lcd.print("s");
  
  // decrease the countdown time by 1 every second
  while (countdown == true){
    countdownTime--;
    // if the countdown time reaches 0, print "Time's up!" on the LCD screen
   
    if (countdownTime == 0) {
      lcd.clear();
      //digitalWrite(buzzerpin, HIGH);
      lcd.print("Time's up!");
      delay(1000);
      //digitalWrite(buzzerpin, LOW);
      delay(1000);
      lcd.clear();
      //digitalWrite(buzzerpin, HIGH);
      delay(1000);
      //digitalWrite(buzzerpin, LOW);
      lcd.print(" BOMB DETONATED");
      lcd.setCursor(0,1);
      lcd.print("       :(");
      delay(750);
      lcd.setCursor(0,1);
      lcd.print("                  ");
      delay(750);
      lcd.setCursor(0,1);
      lcd.print("       :(");
      delay(750);
      lcd.setCursor(0,1);
      lcd.print("               ");
      delay(750);
      lcd.setCursor(0,1);
      lcd.print("       :(");
      delay(750);
      lcd.setCursor(0,1);
      lcd.print("                  ");
      delay(750);
      lcd.setCursor(0,1);
      lcd.print("       :(");
      delay(3000);
      lcd.clear();
      countdown = false;
  }
  // otherwise, print the remaining countdown time on the LCD screen
  else {
    lcd.setCursor(0, 1);
    lcd.print("-------");
    lcd.print(countdownTime);
    lcd.print("--------");
    delay(1000);    
    }
  }
}

}//end countdown

//////////////////////////////////////
//SerialnumPuzzle
void SerialnumPuzzle(){
  char key = keypad.getKey();
  static int index = 0;
  static char input[3];
  
    if (key) {
    if (key == '#') {
      if (input[0] == '0' && index == 1) {
        Serial.println("Invalid input");
        index = 0;
        input[0] = '\0';
        return;
      }
      int inputNum1 = input[0] - '0';
      int inputNum2 = input[1] - '0';
      int inputNum3 = input[2] - '0';
      if (inputNum1 == realNum1 && inputNum2 == realNum2 && inputNum3 == realNum3) {
        Serial.println("Success!");
        tft.setTextColor(TFT_YELLOW);
        tft.setTextSize(2);
        tft.drawString("CORRECT!!",150,150);
      } else {
        Serial.println("Incorrect input.");
        tft.setTextColor(TFT_YELLOW);
        tft.setTextSize(2);
        tft.drawString("INCORRECT!!",150,150);
      }
      index = 0;
      input[0] = '\0';
    } else if (key == '*') {
      Serial.println("Input cleared.");
      index = 0;
      input[0] = '\0';
    } else if (index < 3 && key >= '0' && key <= '9') {
      input[index] = key;
      index++;
    }
  }
}//end decode

//////////////////////////////////////
//lightPuzzle
void lightPuzzle(){
// Turn on a random number of LEDs
  int numLedsOn = random(0,9);
  for (int i = 0; i < numLeds; i++) {
    digitalWrite(ledPins[i], i < numLedsOn);
  }
  
  // Wait for 5 seconds
  delay(5000);
  
  // Turn off all LEDs
  for (int i = 0; i < numLeds; i++) {
    digitalWrite(ledPins[i], LOW);
  }

  // Wait for user input
  String code = "";
  while (true) {
    char key = keypad.getKey();
    if (key == '#') {
      break;
    } else if (key == '*') {
      code = "";
    } else if (key) {
      code += key;
    }
  }

  // Check code based on number of LEDs on
  String expectedCode;
  switch (numLedsOn) {
    case 3:
      expectedCode = "A19";
      break;
    case 4:
      expectedCode = "B67";
      break;
    case 5:
      expectedCode = "C03";
      break;
    case 6:
      expectedCode = "D42";
      break;
    case 7:
      expectedCode = "A32";
      break;
    case 8:
      expectedCode = "B44";
      break;
    default:
      expectedCode = "200";
  }
  
  // Check user input
  if (code == expectedCode) {
    Serial.println("Code correct!");
  } else {
    Serial.println("Code incorrect.");
  }
}//endlightPuzzle

//////////////////////////////////////
//arrowPuzzle
void arrowPuzzle(){
//code for selecting the button colour
  if(selectColour){
    randomNumber = random(0,6);//selects a random number and depending on the one chosen, a colour for the
                               //button is selected.
    
    Serial.print("Random Number: ");
    Serial.print(randomNumber);
    Serial.println();

    //if statement that creates the button and generates the corresponding code
    if(randomNumber == 0){
      //tft.fillCircle(100, 20, 30, RED);
      //tft.setCursor(125, 30);
      //tft.setTextColor(BLACK);
      //tft.setTextSize(3);
      //tft.print("BOMB");
      arrowCode[0] = 3;
      arrowCode[1] = 4;
    } else if (randomNumber == 1){
      //tft.fillCircle(100, 20, 10, YELLOW);
      //tft.setCursor(125, 30);
      //tft.setTextColor(BLACK);
      //tft.setTextSize(3);
      //tft.print("BOMB");
      arrowCode[0] = 1;
      arrowCode[1] = 2;
    } else if (randomNumber == 2){
      //tft.fillCircle(100, 20, 10, BLUE);
      //tft.setCursor(125, 30);
      //tft.setTextColor(BLACK);
      //tft.setTextSize(3);
      //tft.print("BOMB");
      arrowCode[0] = 4;
      arrowCode[1] = 3;
    } else if (randomNumber == 3){
      //tft.fillCircle(100, 20, 10, GREEN);
      //tft.setCursor(125, 30);
      //tft.setTextColor(BLACK);
      //tft.setTextSize(3);
      //tft.print("BOMB");
      arrowCode[0] = 2;
      arrowCode[1] = 1;
    } else if (randomNumber == 4){
      //tft.fillCircle(100, 20, 10, BLACK);
      //tft.setCursor(125, 30);
      //tft.setTextColor(WHITE);
      //tft.setTextSize(3);
      //tft.print("BOMB");
      arrowCode[0] = 2;
      arrowCode[1] = 3;
    } else {
      //tft.fillCircle(100, 20, 10, WHITE);
      //tft.setCursor(125, 30);
      //tft.setTextColor(BLACK);
      //tft.setTextSize(3);
      //tft.print("BOMB");
      arrowCode[0] = 1;
      arrowCode[1] = 4;
    }

    selectColour = false;
  }//end select colour loop

  //Generating number of wires
  if(wireGen){
    //This generates the number of wires and prints them to the tft screen
    numWires = random(0,4);
    //int wireXPos = 20;
    //for(int i = 0; i < numWires; i++){
     // tft.fillRect(wireXPos, 30, 15, 50, BLUE);
     // wireXPos += 25;
    //}//end for
    Serial.print("Number of wires: ");
    Serial.print(numWires);
    //This generates the code the user needs to solve depending on the number of wires
    if (numWires == 0){
      arrowCode[2] = 4;
      arrowCode[3] = 3;
      arrowCode[4] = 1;
    } else if (numWires == 1){
      arrowCode[2] = 3;
      arrowCode[3] = 3;
      arrowCode[4] = 1;
    } else if (numWires == 2){
      arrowCode[2] = 4;
      arrowCode[3] = 3;
      arrowCode[4] = 2;
    } else if (numWires == 3){
      arrowCode[2] = 1;
      arrowCode[3] = 1;
      arrowCode[4] = 2;
    }//end if else statement
  
    wireGen = false;
  }//end wireGen

  //This is the serial number puzzle solving corresponder thing
  for(int i = 0; i < sizeof(serialNumber); i++){
    if (serialNumber[i] == 0){
      arrowCode[5] = 3;
      break;
    } else if (serialNumber[i] == 3){
      arrowCode[5] = 2;
      break;
    } else if (serialNumber[i] == 6){
      arrowCode[5] = 1;
      break;      
    } else if (i == (sizeof(serialNumber))-1){
      arrowCode[5] = 4;
    }
  }//end serial number

  //This is where the user presses the corresponding buttons to solve the puzzle
  if (arrowCodeIndex < 6){
    buttonState = digitalRead(buttonPin);  // read the state of the button
    if (buttonState != lastButtonState) {  // check if button state has changed
      delay(50);  // debounce delay to filter out button noise
      if (buttonState == LOW) {   // check if button is pressed
        // do something when button is pressed
      }
      else {  // button is released
        // do something when button is released
        Serial.println("UP"); // print statement to serial monitor
        arrowCodeEnter[arrowCodeIndex] = 1;
        arrowCodeIndex += 1;
      }
      lastButtonState = buttonState;  // store the current button state as the last state
    }

    buttonState2 = digitalRead(buttonPin2);
    if (buttonState2 != lastButtonState2){
      delay(50);
      if (buttonState2 == LOW){

      } else {
        Serial.println("DOWN");
        arrowCodeEnter[arrowCodeIndex] = 2;
        arrowCodeIndex += 1;
      }
      lastButtonState2 = buttonState2;
    }

    buttonState3 = digitalRead(buttonPin3);
    if (buttonState3 != lastButtonState3){
      delay(50);
      if (buttonState3 == LOW){

      } else {
        Serial.println("LEFT");
        arrowCodeEnter[arrowCodeIndex] = 3;
        arrowCodeIndex += 1;
      }
      lastButtonState3 = buttonState3;
    }

    buttonState4 = digitalRead(buttonPin4);
    if (buttonState4 != lastButtonState4){
      delay(50);
      if (buttonState4 == LOW){

      } else {
        Serial.println("RIGHT");
        arrowCodeEnter[arrowCodeIndex] = 4;
        arrowCodeIndex += 1;
      }
      lastButtonState4 = buttonState4;
    }
  }//to enter the code

  if(arrowCodeIndex == 6){
    for(int i = 0; i < sizeof(arrowCode); i++){
      if(arrowCode[i] != arrowCodeEnter[i]){
        wipeArrowCodeEnter();
        break;
      } else if (i == sizeof(arrowCode)-1){
        UPdownPuzzleSolve = true;
        Serial.println("You solved the puzzle!");
      }//end else if
    }//end for
  }//end if
}//endArrowPuzzle

//////////////////////////////////////
//wipe arrowCodeEnter
void wipeArrowCodeEnter(){
  for(int i = 0; i < sizeof(arrowCodeEnter); i++){
    arrowCodeEnter[i] = 0;
  }
  arrowCodeIndex = 0;
}//end wipeArrowCodeEnter
